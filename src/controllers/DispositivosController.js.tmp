const { SerialPort } = require('serialport');
const { BrowserWindow } = require('electron');
const Store = require('electron-store');
const path = require('path');
const DatabaseController = require('./DatabaseController');
const { execSync } = require('child_process');
const fs = require('fs');
const os = require('os');

class DispositivosController {
  constructor() {
    this.store = new Store();
    this.port = null;
    this.mainWindow = null;
    this.db = new DatabaseController();
  }

  setMainWindow(window) {
    this.mainWindow = window;
    console.log('Ventana principal asignada al controlador de dispositivos');
  }

  async getImpresionConfig() {
    try {
      // Obtener todas las configuraciones de impresión
      const results = await Promise.all([
        this.db.executeQuery('SELECT objeto, posx, posy, TEXTo FROM impresion ORDER BY objeto'),
        this.db.executeQuery('SELECT nombre, valor FROM impresionauxiliar ORDER BY nombre'),
        this.db.executeQuery('SELECT offset FROM impresionoffset LIMIT 1')
      ]);

      const [impresion, auxiliar, offset] = results;
      
      return {
        impresion: impresion || [],
        auxiliar: auxiliar || [],
        offset: offset?.[0]?.offset || 0
      };
    } catch (error) {
      console.error('Error obteniendo configuración de impresión:', error);
      return null;
    }
  }

  // Obtener lista de impresoras del sistema
  async getPrinters() {
    try {
      const util = require('util');
      const exec = util.promisify(require('child_process').exec);
      const printers = [];
      
      // En Windows, usar WMIC para obtener la lista de impresoras
      const { stdout, stderr } = await exec('wmic printer get name');
      
      if (stderr) {
        console.error('Error ejecutando WMIC:', stderr);
      }
      
      if (stdout) {
        // Procesar la salida de WMIC
        const lines = stdout.split('\n')
          .map(line => line.trim())
          .filter(line => line && line !== 'Name');
        
        for (const printerName of lines) {
          if (printerName) {
            printers.push({
              name: printerName,
              displayName: printerName,
              description: 'Impresora del sistema',
              isDefault: false
            });
          }
        }
        
        // Intentar identificar la impresora predeterminada
        try {
          const { stdout: defaultPrinter } = await exec('reg query "HKCU\\Software\\Microsoft\\Windows NT\\CurrentVersion\\Windows" /v Device');
          if (defaultPrinter) {
            const defaultMatch = defaultPrinter.match(/([^,]+)/);
            if (defaultMatch) {
              const defaultName = defaultMatch[1].trim();
              printers.forEach(p => {
                if (p.name === defaultName) {
                  p.isDefault = true;
                }
              });
            }
          }
        } catch (defaultError) {
          console.warn('Error obteniendo impresora predeterminada:', defaultError);
        }
      }

      return { 
        success: true, 
        printers: printers.sort((a, b) => a.name.localeCompare(b.name))
      };
    } catch (error) {
      console.error('Error obteniendo impresoras:', error);
      return { success: false, error: error.message, printers: [] };
    }
  }

  // Obtener impresora guardada
  async getSavedPrinter() {
    try {
      const result = await this.db.executeQuery(
        'SELECT valor FROM configuracion_dispositivos WHERE tipo = ?',
        ['printer']
      );
      const printer = result.length > 0 ? result[0].valor : null;
      return { success: true, printer };
    } catch (error) {
      console.error('Error obteniendo impresora guardada:', error);
      return { success: false, error: error.message };
    }
  }

  // Guardar impresora seleccionada
  async savePrinter(printerName) {
    try {
      await this.db.runQuery(
        `INSERT OR REPLACE INTO configuracion_dispositivos (tipo, valor, configuracion) 
         VALUES (?, ?, ?)`,
        ['printer', printerName, JSON.stringify({name: printerName, timestamp: new Date().toISOString()})]
      );
      return { success: true };
    } catch (error) {
      console.error('Error guardando impresora:', error);
      return { success: false, error: error.message };
    }
  }

  // Test de impresora
  async testPrinter(printerName) {
    try {
      // Obtener configuración de impresión
      const config = await this.getImpresionConfig();
      if (!config) {
        return { success: false, error: 'Error obteniendo configuración de impresión' };
      }

      // Crear contenido de prueba usando la configuración
      const testContent = [
        '\x1B\x40',  // Inicializar impresora
        '\x1B\x21\x08',  // Enfatizado
        '=== PRUEBA DE IMPRESIÓN ===\n\n',
        'Impresora: ' + printerName + '\n',
        'Fecha: ' + new Date().toLocaleString() + '\n\n',
        'Configuración cargada:\n',
        '-----------------------\n',
        `Offset Y: ${config.offset}\n`,
        '\n'
      ];

      // Agregar algunos elementos de configuración como ejemplo
      if (config.impresion.length > 0) {
        testContent.push('Elementos configurados:\n');
        config.impresion.slice(0, 3).forEach(item => {
          const text = item.TEXTo ? ` (${item.TEXTo})` : '';
          testContent.push(`${item.objeto}: (${item.posx},${item.posy})${text}\n`);
        });
      }

      // Agregar configuraciones auxiliares
      if (config.auxiliar.length > 0) {
        testContent.push('\nConfiguraciones auxiliares:\n');
        config.auxiliar.slice(0, 3).forEach(item => {
          testContent.push(`${item.nombre}: ${item.valor}\n`);
        });
      }

      testContent.push(
        '\n=== FIN DE PRUEBA ===\n',
        '\x1B\x21\x00',  // Reset formato
        '\n\n\n\n',      // Avance de papel
        '\x1B\x69'       // Cortar papel
      );

      // Enviar a imprimir usando la configuración de la base de datos
      try {
        // Crear archivo temporal
        const tempFile = path.join(os.tmpdir(), 'print_test.txt');
        
        // Guardar contenido en archivo temporal con codificación correcta
        fs.writeFileSync(tempFile, Buffer.from(testContent.join('')));
        
        // Imprimir usando copy con comandos de impresora
        execSync(`copy /b "${tempFile}" "${printerName}"`, { windowsHide: true });
        
        // Limpiar archivo temporal
        fs.unlinkSync(tempFile);
        
        console.log('Prueba enviada a impresión correctamente');
        return { success: true };
      } catch (printError) {
        console.error('Error enviando a impresora:', printError);
        return { success: false, error: 'Error al enviar a la impresora: ' + printError.message };
      }
    } catch (error) {
      console.error('Error en prueba de impresión:', error);
      return { success: false, error: error.message };
    }
  }

  // Obtener puertos seriales disponibles
  async getSerialPorts() {
    try {
      const ports = await SerialPort.list();
      return { success: true, ports };
    } catch (error) {
      console.error('Error obteniendo puertos seriales:', error);
      return { success: false, error: error.message };
    }
  }

  // Obtener configuración guardada del puerto serial
  async getSavedSerialPort() {
    try {
      const result = await this.db.executeQuery(
        'SELECT valor, configuracion FROM configuracion_dispositivos WHERE tipo = ?',
        ['scanner']
      );
      
      if (result.length > 0) {
        const config = JSON.parse(result[0].configuracion || '{}');
        return { 
          success: true, 
          port: result[0].valor,
          config: {
            baudRate: config.baudRate || 9600,
            dataBits: config.dataBits || 8,
            stopBits: config.stopBits || 1,
            parity: config.parity || 'none'
          }
        };
      }
      return { success: true, port: null, config: null };
    } catch (error) {
      console.error('Error obteniendo configuración del puerto serial:', error);
      return { success: false, error: error.message };
    }
  }

  // Guardar configuración del puerto serial
  async saveSerialPort(port, config) {
    try {
      await this.db.runQuery(
        `INSERT OR REPLACE INTO configuracion_dispositivos (tipo, valor, configuracion) 
         VALUES (?, ?, ?)`,
        ['scanner', port, JSON.stringify(config)]
      );
      return { success: true };
    } catch (error) {
      console.error('Error guardando configuración del puerto serial:', error);
      return { success: false, error: error.message };
    }
  }

  // Test del scanner
  async testScanner(portName, config) {
    try {
      if (this.port) {
        await this.closeSerialPort();
      }

      this.port = new SerialPort({
        path: portName,
        baudRate: config.baudRate,
        dataBits: config.dataBits,
        stopBits: config.stopBits,
        parity: config.parity
      });

      return new Promise((resolve) => {
        this.port.on('open', () => {
          console.log('Puerto serial abierto:', portName);
          resolve({ success: true });
        });

        this.port.on('error', (err) => {
          console.error('Error en puerto serial:', err);
          resolve({ success: false, error: err.message });
        });

        this.port.on('data', (data) => {
          const scannedData = data.toString().trim();
          if (scannedData) {
            if (this.mainWindow) {
              this.mainWindow.webContents.send('barcode-scanned', scannedData);
            }
          }
        });
      });
    } catch (error) {
      console.error('Error en prueba de scanner:', error);
      return { success: false, error: error.message };
    }
  }

  // Cerrar puerto serial
  async closeSerialPort() {
    if (this.port) {
      return new Promise((resolve) => {
        this.port.close(() => {
          this.port = null;
          resolve();
        });
      });
    }
  }
}

module.exports = DispositivosController;